<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>Primitives in C&#43;&#43; for Multithreading | Siddharth C</title>
<meta name="keywords" content="multithreading, C&#43;&#43;" />
<meta name="description" content="Motivation: There are some explanations on certain terminologies commonly seen whenever multithreading is brought up. These terminologies should be somewhat familiar to people who study computer science. However, even when I knew what they meant, I didn&rsquo;t know how they interoperate with other &ldquo;CS thingies&rdquo;. For example, when one of my professor asked a question &ldquo;If a computer just runs one thread at a time, is it necessary to ensure synchronization ?">
<meta name="author" content="Siddharth Chillale">
<link rel="canonical" href="https://siddharthchillale.github.io/blog/multithreading_primitives/primitives/" />
<meta name="google-site-verification" content="XYZabc" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.76747c1ad4f7fada174f38a3675b30e25e84eaf1efdc91e4a4d1e878cf532ac4.css" integrity="sha256-dnR8GtT3&#43;toXTzijZ1sw4l6E6vHv3JHkpNHoeM9TKsQ=" rel="preload stylesheet" as="style">
<link rel="preload" href="profile/sc_logo.png" as="image">
<link rel="icon" href="https://siddharthchillale.github.io/profile/sc_logo.png">
<link rel="icon" type="image/png" sizes="16x16" href="https://siddharthchillale.github.io/profile/sc_logo.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://siddharthchillale.github.io/profile/sc_logo.png">
<link rel="apple-touch-icon" href="https://siddharthchillale.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://siddharthchillale.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.111.2">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
</noscript>
<script async src="https://www.googletagmanager.com/gtag/js?id=G-CMB721BXKS"></script>
<script>
var doNotTrack = false;
if (!doNotTrack) {
	window.dataLayer = window.dataLayer || [];
	function gtag(){dataLayer.push(arguments);}
	gtag('js', new Date());
	gtag('config', 'G-CMB721BXKS', { 'anonymize_ip': false });
}
</script>
<meta property="og:title" content="Primitives in C&#43;&#43; for Multithreading" />
<meta property="og:description" content="Motivation: There are some explanations on certain terminologies commonly seen whenever multithreading is brought up. These terminologies should be somewhat familiar to people who study computer science. However, even when I knew what they meant, I didn&rsquo;t know how they interoperate with other &ldquo;CS thingies&rdquo;. For example, when one of my professor asked a question &ldquo;If a computer just runs one thread at a time, is it necessary to ensure synchronization ?" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://siddharthchillale.github.io/blog/multithreading_primitives/primitives/" />
<meta property="og:image" content="https://siddharthchillale.github.io/blog/multithreading_primitives/primitives/images/multithreading_primitives/multithreaded.png" /><meta property="article:section" content="blog" />
<meta property="article:published_time" content="2023-02-23T19:29:20-05:00" />
<meta property="article:modified_time" content="2023-03-02T11:41:03-05:00" /><meta property="og:site_name" content="Siddharth C" />

<meta name="twitter:card" content="summary_large_image" />
<meta name="twitter:image" content="https://siddharthchillale.github.io/blog/multithreading_primitives/primitives/images/multithreading_primitives/multithreaded.png" />
<meta name="twitter:title" content="Primitives in C&#43;&#43; for Multithreading"/>
<meta name="twitter:description" content="Motivation: There are some explanations on certain terminologies commonly seen whenever multithreading is brought up. These terminologies should be somewhat familiar to people who study computer science. However, even when I knew what they meant, I didn&rsquo;t know how they interoperate with other &ldquo;CS thingies&rdquo;. For example, when one of my professor asked a question &ldquo;If a computer just runs one thread at a time, is it necessary to ensure synchronization ?"/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://siddharthchillale.github.io/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Primitives in C++ for Multithreading",
      "item": "https://siddharthchillale.github.io/blog/multithreading_primitives/primitives/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "Primitives in C++ for Multithreading",
  "name": "Primitives in C\u002b\u002b for Multithreading",
  "description": "Motivation: There are some explanations on certain terminologies commonly seen whenever multithreading is brought up. These terminologies should be somewhat familiar to people who study computer science. However, even when I knew what they meant, I didn\u0026rsquo;t know how they interoperate with other \u0026ldquo;CS thingies\u0026rdquo;. For example, when one of my professor asked a question \u0026ldquo;If a computer just runs one thread at a time, is it necessary to ensure synchronization ?",
  "keywords": [
    "multithreading", "C++"
  ],
  "articleBody": "Motivation: There are some explanations on certain terminologies commonly seen whenever multithreading is brought up. These terminologies should be somewhat familiar to people who study computer science. However, even when I knew what they meant, I didn‚Äôt know how they interoperate with other ‚ÄúCS thingies‚Äù. For example, when one of my professor asked a question ‚ÄúIf a computer just runs one thread at a time, is it necessary to ensure synchronization ?‚Äù, it befuddled me. I wondered if the question made any sense and why were we asked such a question. I also failed to understand how mutexes, locks, semaphores,etc were differ from each other and what does each of them bring to the table. This may make some sense to other people but it just challenged my understanding of multithreading and concurrent programming. One method to solidify our thoughts is to write about it. Hence this article. This article won‚Äôt provide with implementation details on each primitive. It is to throw light on when and where each primitive is useful, and not examples on how to write them in code. Understanding the above question opens up many aspects of concurrent programming. Here we will approach the synchronization primitives made available to use in the STL (C++ 20 and above).\nstd::mutex available in header cppreference\nUsed generally for Exclusion rather than Ordering.\nallows a thread to modify a shared variable.\nMust be released by the same thread that locks it. If not released, then there‚Äôs no way to allow other threads depending on it to run. Ultimately, the process (mostly the application) has to exit to regain control.\nother threads who try to acquire the lock are blocked. What does it mean when a thread is said to be blocked ? The OS uses certain scheduling techniques(FCFS, round robin, MLFQS, etc) to schedule the time certain threads are run. When a thread X is said to be blocked, the thread doesn‚Äôt start executing even when the OS schedules it run. This is the reason, that even when a single thread is run at a time, it is necessary to ensure synchronization. There‚Äôs a possibility that when a thread is executing in its critical section, it is put to the back of the scheduling queue by the OS; and at the same time another thread can run its own critical section. There is no guarantee to make a thread run entirely on its own without being interrupted by the OS, but there are ways to increase the probability of this particular thread being run the most number of times 1. In any case, it is evident that even in a computer where a single thread is executed at a time, it is necessary to ensure synchronization. Remember, that issue of synchronization pops up when you are trying to make a program run by multiple threads and if these threads share some data between them.\nOther threads can avoid being blocked by using try_lock. This tries to own a mutex, but is not blocked if mutex is already taken. This allows the attempting thread to do something else while waiting for the lock to release. This means that when a thread is allowed to work by the OS scheduler, it‚Äôll continue with some other work until the mutex is made available. This is useful, because when though a thread is blocked, the OS has alloted some time units for this thread to work in. This leads to the thread just waiting for the mutex to be free when it could do some other work. This effect is called ‚Äúbusy waiting‚Äù.\nNormally, mutexes are never used in their raw format, they are used along with a lock. C++ STL gives you multiple ways to use a mutex, through std::lock_guard, std::unique_lock and std::scoped_lock.\nIf the shared variables are simple primitive data items then C++ gives you the std::atomic. std::atomic can be used for cpp data types or even shared/weak pointers.\nstd::atomic cppreference\nstd::shared_mutex available in header allows multiple threads shared access if are only going to read from the shared data. Nothing much to it, it works similar to how mutexes are supposed to work except with more flexibility than just blocking any thread. Two types of locking mechanisms are provided : lock() and lock_shared() and their corresponding unlock() calls. lock() allows locking the access to just readers (i.e if you are reading only from the shared data store). lock_shared() allows locking the access to readers and writers (i.e if you are writing to the shared data store). writers have exclusive access. When lock is acquired by writers, readers and other writers are blocked. lock had to be released by the same thread that acquires it. std::shared_mutex cppreference\nstd::scoped_lock/ std::lock_guard / std::unique_lock available in header All three provide a convenient way of owning a mutex through cpp‚Äôs RAII style. lock is released when execution goes out of scope..\nThis is not only to prevent developers‚Äô mistakes of forgetting to release the mutex but also to safeguard against exceptions.\nstd::unique_lock enables a mutex to be moved to another structure like std::condition_variable (more on this later); std::lock_guard provides simple RAII convenience but can only use one mutex. If nesting multiple mutexes is what you need then std::scoped_lock can hold multiple nested mutexes.\nstd::scoped_lock cppreference\nüí° Up until now, you only had to worry about Exclusion. i.e. two threads not changing the same shared variable. But what if you want more control over the order of threads executed. Suppose you have an application where you wish to display some data that is to be fetched from some an online repo, you have a function that does this fetching.\nNow you have heard about this new thing called multithreading and want to be very efficient with your time, so you assign another thread to fetch this data. You now have two threads, main and fetcher threads. you delegate the fetcher to fetch the data and allow your main to display the data. but how can the main display the data when the fetcher is made to sleep by the OS. The main thread doesn‚Äôt know what happened to the fetcher thread or how long it‚Äôll take to get the data. While the fetcher is sleeping, the main thread displays nothing and probably exits. This is a problem because you have to make the main thread wait until the fetcher thread does its job.\nThis means you want some kind of mechanism to handle the order of execution to be such that main displays only when fetcher is done its job. This leads to the process of ‚ÄúSynchronizing‚Äù the threads. Following are some thingies made available by the C++ STL to make this power of synchronization available to programmers.\nCircumstances which benefit from a particular primitive.\nstd::condition_variable (aka cv) available in header has a queue that holds the waiting threads blocked due to some condition on the shared variable.\nThreads are blocked until another thread both modifies the shared condition and notifies the condition_variable.\nRequires a mutex to work. specifically std::unique_lock. One condition variable should work only with single mutex. Whereas, multiple condition variables can share a single mutex. The cv queue is handled by the condition variable object, and has nothing to do with the mutex associated with the cv.\nTo block a thread on some condition, use cv.wait( lock, function ) . The function does the checking of a shared variable, and you require a lock to read this variable as it is shared between threads.\nThe Thread that wants to change the shared variable must acquire a mutex, modify the shared variable if it wants and then release the mutex, and notify cv. After notifying cv, the cv checks if the condition predicate is true and unblocks a waiting thread if it is true.\nThe example given in cpp reference doc is good and I‚Äôd recommend to give it a read an undestand what‚Äôs happening.\nstd::condition_variable cppreference\nstd::counting_semaphore, std::binary_semaphore (from C++ 20) available in header Think of a semaphore as a charging brick with multiple ports. The number of ports is analogous to the count in a counting semaphore. You can only attach a fixed number of devices to the ports. Other devices that wish to connect to these ports must wait for ports to open up.\nA counting semaphore has a mutex, a condition variable, and count c. In std::counting_semaphore one needs only to mention count c for constructing a c_semaphore.\nA binary semaphore is when the counting c is 1. Which allows only one thread to use the shared resource. This differs from a mutex in the sense of ownership. Mutex has to be released by the calling thread as it is owned by the calling thread. A binary_semapahore can be released by other threads even if they are not the owner of that lock.\nThis is similar to a cv in the sense that threads wait on the condition of c becoming \u003e 0.\nUsed mainly for signalling/notifying rather than mutual exclusion. How ? By blocking other semaphores that are required by the other threads. A little rude maybe but it works. Semaphores are useful for having that particular order in execution of threads. Allowing access to a resource is done by a mutex/lock, making it efficient to determine (who among those allowed) gets the resource is done by a condition variable, and having a certain order in accessing this resource is done by a semaphore.\nstd::counting_semaphore, std::binary_semaphore cppreference\nstd::barriers (from C++ 20) available in header Used mainly for thread coordination. A barrier is a door which waits for a certain number of threads to come to it. Threads do not wait on some condition to become true. They simply wait till the barrier receives enough number of threads requesting for this particular resource.\nConsiders number of threads to wait for the barrier to release. Barrier is released when c number of threads are blocked on the wait() condition.\nCan be reused unlike std::latch\nstd::barriers cppreference\nstd::latch (from C++ 20) available in header Used mainly for thread coordination. This is similar to std::barrier in sense that threads are made to wait on an external variable that is not used in their critical section. They wait until a latch is opened.\nA latch doesn‚Äôt require a thread to block itself to signal release of the barrier. Barrier is released when the a thread calls the count_down() function. Calling the count_down() function doesn‚Äôt block this thread.\nCalling thread can decrement latch multiple times.\nstd::latch cppreference\nstd::future (similar to Promise in js) This is similar to how Promise works in js. If a function is run asynchronously, it‚Äôs return value is stored as a std::future object. waiting on this future object blocks the thread until the value is made available. Otherwise, the thread is free to continue working its own logic.\nstd::future cppreference\nOne ways that I know how this could be done is by assigning priority to a thread. However, even this doesn‚Äôt guarantee that a thread will not be interrupted. This is because kernel threads may have a higher priority than threads of user programs and this cannot be controlled without kernel privileges.¬†‚Ü©Ô∏é\n",
  "wordCount" : "1866",
  "inLanguage": "en",
  "image":"https://siddharthchillale.github.io/blog/multithreading_primitives/primitives/images/multithreading_primitives/multithreaded.png","datePublished": "2023-02-23T19:29:20-05:00",
  "dateModified": "2023-03-02T11:41:03-05:00",
  "author":{
    "@type": "Person",
    "name": "Siddharth Chillale"
  },
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://siddharthchillale.github.io/blog/multithreading_primitives/primitives/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Siddharth C",
    "logo": {
      "@type": "ImageObject",
      "url": "https://siddharthchillale.github.io/profile/sc_logo.png"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    }

</script>
<link href="https://fonts.googleapis.com/css2?family=Roboto+Slab&display=swap" rel="stylesheet">

<header class="header gradient_background">
    <nav class="nav">
        <div class="logo">
            <a href="https://siddharthchillale.github.io/" accesskey="h" title="Siddharth (Alt + H)">
                <img src="https://siddharthchillale.github.io/profile/sc_logo.png" alt="logo" aria-label="logo"
                    height="36">Siddharth</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu">
            <li>
                <a href="https://siddharthchillale.github.io/docs/siddharth-chillale-resume.pdf" title="Resume üì•">
                    <span>Resume üì•</span>
                </a>
            </li>
            <li>
                <a href="https://siddharthchillale.github.io/projects/" title="Projects üìë">
                    <span>Projects üìë</span>
                </a>
            </li>
            <li>
                <a href="https://siddharthchillale.github.io/blog/" title="Blog üß†">
                    <span>Blog üß†</span>
                </a>
            </li>
            <li>
                <a href="https://siddharthchillale.github.io/about/" title="About üë§">
                    <span>About üë§</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    <div class="breadcrumbs"><a href="https://siddharthchillale.github.io/">Home</a>&nbsp;¬ª&nbsp;<a href="https://siddharthchillale.github.io/blog/">Blogs</a></div>
    <h1 class="post-title">
      Primitives in C&#43;&#43; for Multithreading
    </h1>
    <div class="post-meta"><span title='2023-02-23 19:29:20 -0500 EST'>February 23, 2023</span>&nbsp;¬∑&nbsp;9 min&nbsp;¬∑&nbsp;Siddharth Chillale&nbsp;|&nbsp;<a href="https://github.com/siddharthchillale.github.io/content/blog/multithreading_primitives/primitives.md" rel="noopener noreferrer" target="_blank">Suggest Changes</a>

</div>
  </header> 
<figure class="entry-cover"><img loading="lazy" src="https://siddharthchillale.github.io/images/multithreading_primitives/multithreaded.png" alt="Tied up in threads">
        <p>Tied up in threads</p>
</figure><div class="toc">
    <details >
        <summary accesskey="c" title="(Alt + C)">
            <span class="details">Table of Contents</span>
        </summary>

        <div class="inner"><ul>
                <li>
                    <a href="#motivation" aria-label="Motivation:">Motivation:</a></li>
                <li>
                    <a href="#stdmutex" aria-label="std::mutex">std::mutex</a></li>
                <li>
                    <a href="#stdshared_mutex" aria-label="std::shared_mutex">std::shared_mutex</a></li>
                <li>
                    <a href="#stdscoped_lock-stdlock_guard--stdunique_lock" aria-label="std::scoped_lock/ std::lock_guard / std::unique_lock">std::scoped_lock/ std::lock_guard / std::unique_lock</a></li>
                <li>
                    <a href="#stdcondition_variable-aka-cv" aria-label="std::condition_variable (aka cv)">std::condition_variable (aka cv)</a></li>
                <li>
                    <a href="#stdcounting_semaphore-stdbinary_semaphore" aria-label="std::counting_semaphore, std::binary_semaphore">std::counting_semaphore, std::binary_semaphore</a></li>
                <li>
                    <a href="#stdbarriers" aria-label="std::barriers">std::barriers</a></li>
                <li>
                    <a href="#stdlatch" aria-label="std::latch">std::latch</a></li>
                <li>
                    <a href="#stdfuture-similar-to-promise-in-js" aria-label="std::future (similar to Promise in js)">std::future (similar to Promise in js)</a>
                </li>
            </ul>
        </div>
    </details>
</div>

  <div class="post-content"><h2 id="motivation">Motivation:<a hidden class="anchor" aria-hidden="true" href="#motivation">#</a></h2>
<p>There are some explanations on certain terminologies commonly seen whenever multithreading is brought up. These terminologies should be somewhat familiar to people who study computer science. However, even when I knew what they meant, I didn&rsquo;t know how they interoperate with other &ldquo;CS thingies&rdquo;. For example, when one of my professor asked a question &ldquo;If a computer just runs one thread at a time, is it necessary to ensure synchronization ?&rdquo;, it befuddled me. I wondered if the question made any sense and why were we asked such a question. I also failed to understand how mutexes, locks, semaphores,etc were differ from each other and what does each of them bring to the table. This may make some sense to other people but it just challenged my understanding of multithreading and concurrent programming. One method to solidify our thoughts is to write about it. Hence this article.
This article won&rsquo;t provide with implementation details on each primitive. It is to throw light on when and where each primitive is useful, and not examples on how to write them in code.
Understanding the above question opens up many aspects of concurrent programming.  Here we will approach the synchronization primitives made available to use in the STL (C++ 20 and above).</p>
<h2 id="stdmutex">std::mutex<a hidden class="anchor" aria-hidden="true" href="#stdmutex">#</a></h2>
<p>available in header <code>&lt;mutex&gt;</code>
<a href="https://en.cppreference.com/w/cpp/thread/mutex">cppreference</a></p>
<p><em>Used generally for Exclusion rather than Ordering.</em></p>
<ol>
<li>
<p>allows a thread to modify a shared variable.</p>
</li>
<li>
<p><strong>Must be released by the same thread that locks it</strong>. If not released, then there&rsquo;s no way to allow other threads depending on it to run. Ultimately, the process (mostly the application) has to exit to regain control.</p>
</li>
<li>
<p>other threads who try to acquire the lock are blocked. What does it mean when a thread is said to be blocked ? The OS uses certain scheduling techniques(FCFS, round robin, MLFQS, etc) to schedule the time certain threads are run. When a thread X is said to be blocked, the thread doesn&rsquo;t start executing even when the OS schedules it run. This is the reason, that even when a single thread is run at a time, it is necessary to ensure synchronization. There&rsquo;s a possibility that when a thread is executing in its critical section, it is put to the back of the scheduling queue by the OS; and at the same time another thread can run its own critical section. There is no guarantee to make a thread run entirely on its own without being interrupted by the OS, but there are ways to increase the probability of this particular thread being run the most number of times <sup id="fnref:1"><a href="#fn:1" class="footnote-ref" role="doc-noteref">1</a></sup>. In any case, it is evident that even in a computer where a single thread is executed at a time, it is necessary to ensure synchronization. Remember, that issue of synchronization pops up when you are trying to make a program run by multiple threads and if these threads share some data between them.</p>
</li>
<li>
<p>Other threads can avoid being blocked by using <code>try_lock</code>. This tries to own a mutex, but is not blocked if mutex is already taken. This allows the attempting thread to do something else while waiting for the lock to release. This means that when a thread is allowed to work by the OS scheduler, it&rsquo;ll continue with some other work until the mutex is made available. This is useful, because when though a thread is blocked, the OS has alloted some time units for this thread to work in. This leads to the thread just waiting for the mutex to be free when it could do some other work. This effect is called &ldquo;busy waiting&rdquo;.</p>
</li>
<li>
<p>Normally, mutexes are never used in their raw format, they are used along with a lock. C++ STL gives you multiple ways to use a mutex, through <code>std::lock_guard</code>, <code>std::unique_lock</code> and <code>std::scoped_lock</code>.</p>
</li>
<li>
<p>If the shared variables are simple primitive data items then C++ gives you the std::atomic. std::atomic can be used for cpp data types or even shared/weak pointers.</p>
<p><a href="https://en.cppreference.com/w/cpp/atomic/atomic">std::atomic cppreference</a></p>
</li>
</ol>
<h2 id="stdshared_mutex">std::shared_mutex<a hidden class="anchor" aria-hidden="true" href="#stdshared_mutex">#</a></h2>
<p>available in header <code>&lt;mutex&gt;</code></p>
<ol>
<li>allows multiple threads shared access if are only going to read from the shared data. Nothing much to it, it works similar to how mutexes are supposed to work except with more flexibility than just blocking any thread.</li>
<li>Two types of locking mechanisms are provided : <code>lock()</code> and <code>lock_shared()</code> and their corresponding unlock() calls.
<ol>
<li><code>lock()</code> allows locking the access to just readers (i.e if you are reading only from the shared data store).</li>
<li><code>lock_shared()</code> allows locking the access to readers and writers (i.e if you are writing to the shared data store).</li>
</ol>
</li>
<li>writers have exclusive access. When lock is acquired by writers, readers and other writers are blocked.</li>
<li><strong>lock had to be released by the same thread that acquires it.</strong></li>
</ol>
<p><a href="https://en.cppreference.com/w/cpp/thread/shared_mutex">std::shared_mutex cppreference</a></p>
<h2 id="stdscoped_lock-stdlock_guard--stdunique_lock">std::scoped_lock/ std::lock_guard / std::unique_lock<a hidden class="anchor" aria-hidden="true" href="#stdscoped_lock-stdlock_guard--stdunique_lock">#</a></h2>
<p>available in header <code>&lt;mutex&gt;</code></p>
<ol>
<li>
<p>All three provide a convenient way of owning a mutex through cpp‚Äôs RAII style. <strong>lock is released when execution goes out of scope.</strong>.</p>
</li>
<li>
<p>This is not only to prevent developers&rsquo; mistakes of forgetting to release the mutex but also to safeguard against exceptions.</p>
</li>
<li>
<p><code>std::unique_lock</code> enables a mutex to be moved to another structure like <code>std::condition_variable</code> (more on this later); <code>std::lock_guard</code> provides simple RAII convenience but can only use one mutex. If nesting multiple mutexes is what you need then <code>std::scoped_lock</code> can hold multiple nested mutexes.</p>
<p><a href="https://en.cppreference.com/w/cpp/thread/scoped_lock">std::scoped_lock cppreference</a></p>
</li>
</ol>
<hr>
<p>üí° Up until now, you only had to worry about <em>Exclusion</em>. i.e. two threads not changing the same shared variable.
But what if you want more control over the order of threads executed. Suppose you have an application where you wish to display some data that is to be fetched from some an online repo, you have a function that does this fetching.</p>
<p>Now you have heard about this new thing called multithreading and want to be very efficient with your time, so you assign another thread to fetch this data. You now have two threads, main and fetcher threads. you delegate the fetcher to fetch the data and allow your main to display the data. but how can the main display the data when the fetcher is made to sleep by the OS.
The main thread doesn&rsquo;t know what happened to the fetcher thread or how long it&rsquo;ll take to get the data. While the fetcher is sleeping, the main thread displays nothing and probably exits. This is a problem because you have to make the main thread wait until the fetcher thread does its job.</p>
<p>This means you want some kind of mechanism to handle the order of execution to be such that main displays only when fetcher is done its job. This leads to the process of &ldquo;<em>Synchronizing</em>&rdquo; the threads.
Following are some thingies made available by the C++ STL to make this power of synchronization available to programmers.</p>
<figure class="align-center ">
    <img loading="lazy" src="/images/multithreading_primitives/prim_comp.png#center"
         alt="Circumstances which benefit from a particular primitive."/> <figcaption>
            <p>Circumstances which benefit from a particular primitive.</p>
        </figcaption>
</figure>

<h2 id="stdcondition_variable-aka-cv">std::condition_variable (aka cv)<a hidden class="anchor" aria-hidden="true" href="#stdcondition_variable-aka-cv">#</a></h2>
<p>available in header <code>&lt;condition_variable&gt;</code></p>
<ol>
<li>
<p>has a queue that holds the waiting threads blocked due to some condition on the shared variable.</p>
</li>
<li>
<p>Threads are blocked until another thread both modifies the shared condition and notifies the condition_variable.</p>
</li>
<li>
<p>Requires a mutex to work. specifically <code>std::unique_lock&lt;std::mutex&gt;</code>. One condition variable should work only with single mutex. Whereas, multiple condition variables can share a single mutex. The cv queue is handled by the condition variable object, and has nothing to do with the mutex associated with the cv.</p>
</li>
<li>
<p>To block a thread on some condition, use <code>cv.wait( lock, function )</code> . The <em>function</em> does the checking of a shared variable, and you require a <em>lock</em> to read this variable as it is shared between threads.</p>
</li>
<li>
<p>The Thread that wants to change the shared variable must acquire a mutex, modify the shared variable if it wants and then release the mutex, and notify cv. After notifying cv, the cv checks if the condition predicate is true and unblocks a waiting thread if it is true.</p>
</li>
<li>
<p>The example given in cpp reference doc is good and I&rsquo;d recommend to give it a read an undestand what&rsquo;s happening.</p>
<p><a href="https://en.cppreference.com/w/cpp/thread/condition_variable">std::condition_variable cppreference</a></p>
</li>
</ol>
<h2 id="stdcounting_semaphore-stdbinary_semaphore">std::counting_semaphore, std::binary_semaphore<a hidden class="anchor" aria-hidden="true" href="#stdcounting_semaphore-stdbinary_semaphore">#</a></h2>
<p>(from C++ 20) available in header <code>&lt;semaphore&gt;</code></p>
<ol>
<li>
<p>Think of a semaphore as a charging brick with multiple ports. The number of ports is analogous to the count in a counting semaphore. You can only attach a fixed number of devices to the ports. Other devices that wish to connect to these ports must wait for ports to open up.</p>
</li>
<li>
<p>A counting semaphore has a mutex, a condition variable, and count c. In std::counting_semaphore one needs only to mention count c for constructing a c_semaphore.</p>
</li>
<li>
<p>A binary semaphore is when the counting c is 1. Which allows only one thread to use the shared resource. This differs from a mutex in the sense of ownership. Mutex has to be released by the calling thread as it is owned by the calling thread. A binary_semapahore can be released by other threads even if they are not the owner of that lock.</p>
</li>
<li>
<p>This is similar to a cv in the sense that threads wait on the condition of c becoming &gt; 0.</p>
</li>
<li>
<p>Used mainly for signalling/notifying rather than mutual exclusion. How ? By blocking other semaphores that are required by the other threads. A little rude maybe but it works. Semaphores are useful for having that particular order in execution of threads. Allowing access to a resource is done by a mutex/lock, making it efficient to determine (who among those allowed) gets the resource is done by a condition variable, and having a certain order in accessing this resource is done by a semaphore.</p>
<p><a href="https://en.cppreference.com/w/cpp/thread/counting_semaphore">std::counting_semaphore, std::binary_semaphore cppreference</a></p>
</li>
</ol>
<h2 id="stdbarriers">std::barriers<a hidden class="anchor" aria-hidden="true" href="#stdbarriers">#</a></h2>
<p>(from C++ 20) available in header <code>&lt;barrier&gt;</code></p>
<ol>
<li>
<p>Used mainly for thread coordination. A barrier is a door which waits for a certain number of threads to come to it. Threads do not wait on some condition to become true. They simply wait till the barrier receives enough number of threads requesting for this particular resource.</p>
</li>
<li>
<p>Considers number of threads to wait for the barrier to release. Barrier is released when c number of threads are blocked on the <code>wait()</code> condition.</p>
</li>
<li>
<p>Can be reused unlike <code>std::latch</code></p>
<p><a href="https://en.cppreference.com/w/cpp/thread/barrier">std::barriers cppreference</a></p>
</li>
</ol>
<h2 id="stdlatch">std::latch<a hidden class="anchor" aria-hidden="true" href="#stdlatch">#</a></h2>
<p>(from C++ 20) available in header <code>&lt;latch&gt;</code></p>
<ol>
<li>
<p>Used mainly for thread coordination. This is similar to <code>std::barrier</code> in sense that threads are made to wait on an external variable that is not used in their critical section. They wait until a latch is opened.</p>
</li>
<li>
<p>A latch doesn‚Äôt require a thread to block itself to signal release of the barrier. Barrier is released when the a thread calls the <code>count_down()</code> function. Calling the <code>count_down()</code> function doesn‚Äôt block this thread.</p>
</li>
<li>
<p>Calling thread can decrement latch multiple times.</p>
<p><a href="https://en.cppreference.com/w/cpp/thread/latch">std::latch cppreference</a></p>
</li>
</ol>
<h2 id="stdfuture-similar-to-promise-in-js">std::future (similar to Promise in js)<a hidden class="anchor" aria-hidden="true" href="#stdfuture-similar-to-promise-in-js">#</a></h2>
<p>This is similar to how Promise works in js. If a function is run asynchronously, it&rsquo;s return value is stored as a std::future object. waiting on this future  object blocks the thread until the value is made available. Otherwise, the thread is free to continue working its own logic.</p>
<p><a href="https://en.cppreference.com/w/cpp/thread/future">std::future cppreference</a></p>
<div class="footnotes" role="doc-endnotes">
<hr>
<ol>
<li id="fn:1">
<p>One ways that I know how this could be done is by assigning priority to a thread. However, even this doesn&rsquo;t guarantee that a thread will not be interrupted. This is because kernel threads may have a higher priority than threads of user programs and this cannot be controlled without kernel privileges.&#160;<a href="#fnref:1" class="footnote-backref" role="doc-backlink">&#x21a9;&#xfe0e;</a></p>
</li>
</ol>
</div>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://siddharthchillale.github.io/tags/multithreading/">multithreading</a></li>
      <li><a href="https://siddharthchillale.github.io/tags/c&#43;&#43;/">C&#43;&#43;</a></li>
    </ul>


<div class="share-buttons">
    <a target="_blank" rel="noopener noreferrer" aria-label="share Primitives in C&#43;&#43; for Multithreading on twitter"
        href="https://twitter.com/intent/tweet/?text=Primitives%20in%20C%2b%2b%20for%20Multithreading&amp;url=https%3a%2f%2fsiddharthchillale.github.io%2fblog%2fmultithreading_primitives%2fprimitives%2f&amp;hashtags=multithreading%2cC%2b%2b">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-253.927,424.544c135.939,0 210.268,-112.643 210.268,-210.268c0,-3.218 0,-6.437 -0.153,-9.502c14.406,-10.421 26.973,-23.448 36.935,-38.314c-13.18,5.824 -27.433,9.809 -42.452,11.648c15.326,-9.196 26.973,-23.602 32.49,-40.92c-14.252,8.429 -30.038,14.56 -46.896,17.931c-13.487,-14.406 -32.644,-23.295 -53.946,-23.295c-40.767,0 -73.87,33.104 -73.87,73.87c0,5.824 0.613,11.494 1.992,16.858c-61.456,-3.065 -115.862,-32.49 -152.337,-77.241c-6.284,10.881 -9.962,23.601 -9.962,37.088c0,25.594 13.027,48.276 32.95,61.456c-12.107,-0.307 -23.448,-3.678 -33.41,-9.196l0,0.92c0,35.862 25.441,65.594 59.311,72.49c-6.13,1.686 -12.72,2.606 -19.464,2.606c-4.751,0 -9.348,-0.46 -13.946,-1.38c9.349,29.426 36.628,50.728 68.965,51.341c-25.287,19.771 -57.164,31.571 -91.8,31.571c-5.977,0 -11.801,-0.306 -17.625,-1.073c32.337,21.15 71.264,33.41 112.95,33.41Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Primitives in C&#43;&#43; for Multithreading on linkedin"
        href="https://www.linkedin.com/shareArticle?mini=true&amp;url=https%3a%2f%2fsiddharthchillale.github.io%2fblog%2fmultithreading_primitives%2fprimitives%2f&amp;title=Primitives%20in%20C%2b%2b%20for%20Multithreading&amp;summary=Primitives%20in%20C%2b%2b%20for%20Multithreading&amp;source=https%3a%2f%2fsiddharthchillale.github.io%2fblog%2fmultithreading_primitives%2fprimitives%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-288.985,423.278l0,-225.717l-75.04,0l0,225.717l75.04,0Zm270.539,0l0,-129.439c0,-69.333 -37.018,-101.586 -86.381,-101.586c-39.804,0 -57.634,21.891 -67.617,37.266l0,-31.958l-75.021,0c0.995,21.181 0,225.717 0,225.717l75.02,0l0,-126.056c0,-6.748 0.486,-13.492 2.474,-18.315c5.414,-13.475 17.767,-27.434 38.494,-27.434c27.135,0 38.007,20.707 38.007,51.037l0,120.768l75.024,0Zm-307.552,-334.556c-25.674,0 -42.448,16.879 -42.448,39.002c0,21.658 16.264,39.002 41.455,39.002l0.484,0c26.165,0 42.452,-17.344 42.452,-39.002c-0.485,-22.092 -16.241,-38.954 -41.943,-39.002Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Primitives in C&#43;&#43; for Multithreading on reddit"
        href="https://reddit.com/submit?url=https%3a%2f%2fsiddharthchillale.github.io%2fblog%2fmultithreading_primitives%2fprimitives%2f&title=Primitives%20in%20C%2b%2b%20for%20Multithreading">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-3.446,265.638c0,-22.964 -18.616,-41.58 -41.58,-41.58c-11.211,0 -21.361,4.457 -28.841,11.666c-28.424,-20.508 -67.586,-33.757 -111.204,-35.278l18.941,-89.121l61.884,13.157c0.756,15.734 13.642,28.29 29.56,28.29c16.407,0 29.706,-13.299 29.706,-29.701c0,-16.403 -13.299,-29.702 -29.706,-29.702c-11.666,0 -21.657,6.792 -26.515,16.578l-69.105,-14.69c-1.922,-0.418 -3.939,-0.042 -5.585,1.036c-1.658,1.073 -2.811,2.761 -3.224,4.686l-21.152,99.438c-44.258,1.228 -84.046,14.494 -112.837,35.232c-7.468,-7.164 -17.589,-11.591 -28.757,-11.591c-22.965,0 -41.585,18.616 -41.585,41.58c0,16.896 10.095,31.41 24.568,37.918c-0.639,4.135 -0.99,8.328 -0.99,12.576c0,63.977 74.469,115.836 166.33,115.836c91.861,0 166.334,-51.859 166.334,-115.836c0,-4.218 -0.347,-8.387 -0.977,-12.493c14.564,-6.47 24.735,-21.034 24.735,-38.001Zm-119.474,108.193c-20.27,20.241 -59.115,21.816 -70.534,21.816c-11.428,0 -50.277,-1.575 -70.522,-21.82c-3.007,-3.008 -3.007,-7.882 0,-10.889c3.003,-2.999 7.882,-3.003 10.885,0c12.777,12.781 40.11,17.317 59.637,17.317c19.522,0 46.86,-4.536 59.657,-17.321c3.016,-2.999 7.886,-2.995 10.885,0.008c3.008,3.011 3.003,7.882 -0.008,10.889Zm-5.23,-48.781c-16.373,0 -29.701,-13.324 -29.701,-29.698c0,-16.381 13.328,-29.714 29.701,-29.714c16.378,0 29.706,13.333 29.706,29.714c0,16.374 -13.328,29.698 -29.706,29.698Zm-160.386,-29.702c0,-16.381 13.328,-29.71 29.714,-29.71c16.369,0 29.689,13.329 29.689,29.71c0,16.373 -13.32,29.693 -29.689,29.693c-16.386,0 -29.714,-13.32 -29.714,-29.693Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Primitives in C&#43;&#43; for Multithreading on facebook"
        href="https://facebook.com/sharer/sharer.php?u=https%3a%2f%2fsiddharthchillale.github.io%2fblog%2fmultithreading_primitives%2fprimitives%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-106.468,0l0,-192.915l66.6,0l12.672,-82.621l-79.272,0l0,-53.617c0,-22.603 11.073,-44.636 46.58,-44.636l36.042,0l0,-70.34c0,0 -32.71,-5.582 -63.982,-5.582c-65.288,0 -107.96,39.569 -107.96,111.204l0,62.971l-72.573,0l0,82.621l72.573,0l0,192.915l-191.104,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Primitives in C&#43;&#43; for Multithreading on whatsapp"
        href="https://api.whatsapp.com/send?text=Primitives%20in%20C%2b%2b%20for%20Multithreading%20-%20https%3a%2f%2fsiddharthchillale.github.io%2fblog%2fmultithreading_primitives%2fprimitives%2f">
        <svg version="1.1" viewBox="0 0 512 512" xml:space="preserve">
            <path
                d="M449.446,0c34.525,0 62.554,28.03 62.554,62.554l0,386.892c0,34.524 -28.03,62.554 -62.554,62.554l-386.892,0c-34.524,0 -62.554,-28.03 -62.554,-62.554l0,-386.892c0,-34.524 28.029,-62.554 62.554,-62.554l386.892,0Zm-58.673,127.703c-33.842,-33.881 -78.847,-52.548 -126.798,-52.568c-98.799,0 -179.21,80.405 -179.249,179.234c-0.013,31.593 8.241,62.428 23.927,89.612l-25.429,92.884l95.021,-24.925c26.181,14.28 55.659,21.807 85.658,21.816l0.074,0c98.789,0 179.206,-80.413 179.247,-179.243c0.018,-47.895 -18.61,-92.93 -52.451,-126.81Zm-126.797,275.782l-0.06,0c-26.734,-0.01 -52.954,-7.193 -75.828,-20.767l-5.441,-3.229l-56.386,14.792l15.05,-54.977l-3.542,-5.637c-14.913,-23.72 -22.791,-51.136 -22.779,-79.287c0.033,-82.142 66.867,-148.971 149.046,-148.971c39.793,0.014 77.199,15.531 105.329,43.692c28.128,28.16 43.609,65.592 43.594,105.4c-0.034,82.149 -66.866,148.983 -148.983,148.984Zm81.721,-111.581c-4.479,-2.242 -26.499,-13.075 -30.604,-14.571c-4.105,-1.495 -7.091,-2.241 -10.077,2.241c-2.986,4.483 -11.569,14.572 -14.182,17.562c-2.612,2.988 -5.225,3.364 -9.703,1.12c-4.479,-2.241 -18.91,-6.97 -36.017,-22.23c-13.314,-11.876 -22.304,-26.542 -24.916,-31.026c-2.612,-4.484 -0.279,-6.908 1.963,-9.14c2.016,-2.007 4.48,-5.232 6.719,-7.847c2.24,-2.615 2.986,-4.484 4.479,-7.472c1.493,-2.99 0.747,-5.604 -0.374,-7.846c-1.119,-2.241 -10.077,-24.288 -13.809,-33.256c-3.635,-8.733 -7.327,-7.55 -10.077,-7.688c-2.609,-0.13 -5.598,-0.158 -8.583,-0.158c-2.986,0 -7.839,1.121 -11.944,5.604c-4.105,4.484 -15.675,15.32 -15.675,37.364c0,22.046 16.048,43.342 18.287,46.332c2.24,2.99 31.582,48.227 76.511,67.627c10.685,4.615 19.028,7.371 25.533,9.434c10.728,3.41 20.492,2.929 28.209,1.775c8.605,-1.285 26.499,-10.833 30.231,-21.295c3.732,-10.464 3.732,-19.431 2.612,-21.298c-1.119,-1.869 -4.105,-2.99 -8.583,-5.232Z" />
        </svg>
    </a>
    <a target="_blank" rel="noopener noreferrer" aria-label="share Primitives in C&#43;&#43; for Multithreading on telegram"
        href="https://telegram.me/share/url?text=Primitives%20in%20C%2b%2b%20for%20Multithreading&amp;url=https%3a%2f%2fsiddharthchillale.github.io%2fblog%2fmultithreading_primitives%2fprimitives%2f">
        <svg version="1.1" xml:space="preserve" viewBox="2 2 28 28">
            <path
                d="M26.49,29.86H5.5a3.37,3.37,0,0,1-2.47-1,3.35,3.35,0,0,1-1-2.47V5.48A3.36,3.36,0,0,1,3,3,3.37,3.37,0,0,1,5.5,2h21A3.38,3.38,0,0,1,29,3a3.36,3.36,0,0,1,1,2.46V26.37a3.35,3.35,0,0,1-1,2.47A3.38,3.38,0,0,1,26.49,29.86Zm-5.38-6.71a.79.79,0,0,0,.85-.66L24.73,9.24a.55.55,0,0,0-.18-.46.62.62,0,0,0-.41-.17q-.08,0-16.53,6.11a.59.59,0,0,0-.41.59.57.57,0,0,0,.43.52l4,1.24,1.61,4.83a.62.62,0,0,0,.63.43.56.56,0,0,0,.4-.17L16.54,20l4.09,3A.9.9,0,0,0,21.11,23.15ZM13.8,20.71l-1.21-4q8.72-5.55,8.78-5.55c.15,0,.23,0,.23.16a.18.18,0,0,1,0,.06s-2.51,2.3-7.52,6.8Z" />
        </svg>
    </a>
</div>

  </footer>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2023 <a href="https://siddharthchillale.github.io/">Siddharth C</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        if (container.classList.contains("highlight")) {
            container.appendChild(copybutton);
        } else if (container.parentNode.firstChild == container) {
            
        } else if (codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.nodeName == "TABLE") {
            
            codeblock.parentNode.parentNode.parentNode.parentNode.parentNode.appendChild(copybutton);
        } else {
            
            codeblock.parentNode.appendChild(copybutton);
        }
    });
</script>
</body>

</html>
